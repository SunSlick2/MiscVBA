let
    // Get the path from the named cell MXFile
    SourcePath = Excel.CurrentWorkbook(){[Name="MXFile"]}[Content]{0}[Column1],

    // Load the external workbook using the extracted file path
    ExternalWorkbook = Excel.Workbook(File.Contents(SourcePath), null, true),

    // Access specific sheet data
    Sheet1_Sheet = ExternalWorkbook{[Item="Sheet1", Kind="Sheet"]}[Data],
    #"Promoted Headers" = Table.PromoteHeaders(Sheet1_Sheet, [PromoteAllScalars=true]),
    #"Merged Queries" = Table.NestedJoin(#"Promoted Headers", {"COUNTERPART"}, ListofACtoAddFrmMurex, {"Column1"}, "ListofACtoAddFrmMurex", JoinKind.Inner),
    #"Removed Columns" = Table.RemoveColumns(#"Merged Queries",{"Marketer_Name", "TIME", "SYS.DATE", "Marketer", "Counter Party Long Name", "ENTITY", "PORTFOLIO", "XPOPTPMNT", "TRADER", "SCBENTITY", "BRW_RTE2", "ECP0", "ECP1", "XPTCUR_2", "EP0", "ECPE0", "Fixed / Variable 0", "Fixed / Variable 1", "PER_RET", "OLD_CPTY", "SRC_SYSTEM", "Index1", "Index0", "BRW_MRG2", "BRW_MRG1", "VALID", "CVA_USD", "CTRTY_TYPE", "FAMILY", "BO.SIGN", "CALC_AGENT", "ARCH_LABEL", "Our comment 0", "Our comment 1", "Market Comment", "XPOPTDELIV", "FLAG1", "FLAG0", "XPRMPD", "ST_DATE", "ED_DATE", "IRV", "OSR", "RISK_PORT", "Last MOP Description", "TYPE_1", "TYPE_SUB", "TRN_TYPO", "STRUC_INVL", "TRANCHE_ID", "CFC", "GROUP", "NOTIONAL", "MOP SYSTEM DATE", "Start Date", "BRW_RTE1", "NB.LTI", "Our comment 2", "Doc Id", "NB.EXT", "SCI_ID", "G.ID"}),
    #"Reordered Columns" = Table.ReorderColumns(#"Removed Columns",{"COUNTERPART", "INSTRUMENT", "BRW_NOMU1", "QTY.NOMINAL", "BRW_NOMU2", "BRW_NOM2", "XPOPTFPRIC", "B/S", "C/P", "TRN.DATE", "EXPIRY", "TYPE", "A/E", "XPOPTCUTOF", "BARRIER0", "BARRIER1", "XPRMPC", "XPTCUR", "XPRMPA", "CURRENCY1", "TP_STATUS", "NB.INT",  "STRUCT_ID", "STRATEGY","ListofACtoAddFrmMurex"}),
    #"Expanded ListofACtoAddFrmMurex" = Table.ExpandTableColumn(#"Reordered Columns", "ListofACtoAddFrmMurex", {"Column2"}, {"ListofACtoAddFrmMurex.Column2"}),
    #"Removed Columns1" = Table.RemoveColumns(#"Expanded ListofACtoAddFrmMurex",{"COUNTERPART"}),
    #"Reordered Columns1" = Table.ReorderColumns(#"Removed Columns1",{"ListofACtoAddFrmMurex.Column2", "INSTRUMENT", "B/S", "C/P","BRW_NOMU1", "QTY.NOMINAL", "BRW_NOMU2", "BRW_NOM2", "XPOPTFPRIC", "TRN.DATE", "EXPIRY", "TYPE", "A/E", "XPOPTCUTOF", "BARRIER0", "BARRIER1", "XPRMPC", "XPTCUR", "XPRMPA", "CURRENCY1", "TP_STATUS", "NB.INT", "STRUCT_ID", "STRATEGY"}),
    #"Filtered Rows" = Table.SelectRows(#"Reordered Columns1", each [#"C/P"] = "C" or [#"C/P"] = "P"),
    #"Renamed Columns" = Table.RenameColumns(#"Filtered Rows",{{"ListofACtoAddFrmMurex.Column2", "Client"}, {"INSTRUMENT", "CcyPair"}, {"BRW_NOMU1", "BaseCcy"}, {"QTY.NOMINAL", "BaseNot"}, {"BRW_NOMU2", "CounterCcy"}, {"BRW_NOM2", "CounterNot"}, {"XPOPTFPRIC", "Strike"}, {"XPOPTCUTOF", "Cut"}}),
    #"Changed Type" = Table.TransformColumnTypes(#"Renamed Columns",{{"BaseNot", type number}, {"CounterNot", type number}}),
    #"Sorted Rows" = Table.Sort(#"Changed Type",{{"Client", Order.Ascending}}),
    #"Replaced Value" = Table.ReplaceValue(#"Sorted Rows","/","",Replacer.ReplaceText,{"CcyPair"}),

    // Retrieve flip list from named cell
    FlipListRaw = Excel.CurrentWorkbook(){[Name="CcyPairsToFlipList"]}[Content]{0}[Column1],
    FlipListCleaned = Text.Split(Text.Replace(FlipListRaw, " ", ""), ","),

    // Add Flipped column
    #"Add Flipped Column" = Table.AddColumn(#"Replaced Value", "Flipped", each if List.Contains(FlipListCleaned, Text.Replace([CcyPair], " ", "")) then "Yes" else null),

    // Apply conditional swap and CcyPair transformation
    #"Apply Flip Logic" = Table.FromRecords(
        Table.TransformRows(#"Add Flipped Column", each 
            if [Flipped] = "Yes" then
                let r = _
                in Record.TransformFields(r, {
                    {"BaseCcy", each r[CounterCcy]},
                    {"CounterCcy", each r[BaseCcy]},
                    {"BaseNot", each r[CounterNot]},
                    {"CounterNot", each r[BaseNot]},
                    {"CcyPair", each Text.End(r[CcyPair], 3) & Text.Start(r[CcyPair], 3)},
                    {"C/P", each if Record.Field(r, "C/P") = "C" then "P" else if Record.Field(r, "C/P") = "P" then "C" else Record.Field(r, "C/P")}
                })
            else _
        )
    ),

    // Invert B/S values for all rows
    #"Invert B/S" = Table.TransformColumns(#"Apply Flip Logic", {
        {"B/S", each if _ = "B" then "S" else if _ = "S" then "B" else _, type text}
    }),
    #"Changed Type1" = Table.TransformColumnTypes(#"Invert B/S",{{"TRN.DATE", type text}}),
    #"Sort Table" = Table.Sort(#"Changed Type1", {
        {"Client", Order.Ascending},
        {"CcyPair", Order.Ascending},
        {"Strike", Order.Ascending},
        {"STRUCT_ID", Order.Ascending},
        {"BaseNot", Order.Ascending}, 
        {"B/S", Order.Ascending}
        })
in
    #"Sort Table"


Extend this power query such that if two rows of data have same STRUCT_ID and STRATEGY=FX_KOFW. then combine them

For the combined row
STRUCT_ID will the determined such that if for either of the rows B/S = B and C/P = C and the other row has B/S = S and C/P = P, then STRUCT_ID will be Accu or Accu-g and B/S will be L. If the Barrier0 is 0 then STRUCT_ID = Accu-g, else it is Accu. Also, compare the BaseNot amount for both rows. In the combined row, the BaseNot will appear as a text string joing "<BaseNot from row B/S = B and C/P = C> & "/" & "<BaseNot from row B/S = S and C/P = P>. Same treatment is to be applied to CounterNot and NB.INT. Rest of the fields are expected to be the same for both rows and can be combined as is. If any of the fields don't follow the expected pattern, then don't combine the rows.

Further  if for either of the rows B/S = B and C/P = P and the other row has B/S = S and C/P = C, then STRUCT_ID will be Decu or Decu-g and B/S will be S. If the Barrier0 is 0 then STRUCT_ID = Decu-g, else it is Decu. Also, compare the BaseNot amount for both rows. In the combined row, the BaseNot will appear as a text string joinng "<BaseNot from row B/S = B and C/P = P> & "/" & "<BaseNot from row B/S = S and C/P = C>. Same treatment is to be applied to CounterNot.Same treatment is to be applied to CounterNot and NB.INT. Rest of the fields are expected to be the same for both rows and can be combined as is.

Any questions before you proceed?

 